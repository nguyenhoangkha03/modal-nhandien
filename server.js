// const express = require("express");
// const multer = require("multer");
// const fs = require("fs");
// const path = require("path");
// const faceapi = require("face-api.js");
// const canvas = require("canvas");

// const app = express();
// const upload = multer({ dest: "uploads/" });
// const cors = require("cors");
// app.use(cors());

// const { Canvas, Image } = canvas;
// faceapi.env.monkeyPatch({ Canvas, Image });

// const IMAGES_FOLDER = path.join(__dirname, "uploads");
// let faceMatcher;

// // Route m·∫∑c ƒë·ªãnh ƒë·ªÉ tr√°nh l·ªói "Cannot GET /"
// app.get("/", (req, res) => {
//   res.send("Face Recognition API is running!");
// });

// // üìå Load m√¥ h√¨nh nh·∫≠n di·ªán
// const loadModels = async () => {
//   await faceapi.nets.ssdMobilenetv1.loadFromDisk(path.join(__dirname, "models"));
//   await faceapi.nets.faceLandmark68Net.loadFromDisk(path.join(__dirname, "models"));
//   await faceapi.nets.faceRecognitionNet.loadFromDisk(path.join(__dirname, "models"));
//   await loadLabeledImages();
// };

// // üìå ƒê·ªçc v√† m√£ h√≥a ·∫£nh trong folder "uploads"
// const loadLabeledImages = async () => {
//   const labels = fs.readdirSync(IMAGES_FOLDER);
//   const labeledDescriptors = [];

//   for (const label of labels) {
//     const imgPath = path.join(IMAGES_FOLDER, label);
//     const img = await canvas.loadImage(imgPath);
//     const detections = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();

//     if (detections) {
//       // labeledDescriptors.push(new faceapi.LabeledFaceDescriptors(label.split("_").slice(2).join("_"), [detections.descriptor]));
//       const name = label.replace(/^image_\d+_/, "").replace(/\.\w+$/, "");
//       labeledDescriptors.push(new faceapi.LabeledFaceDescriptors(name, [detections.descriptor]));
//     }
//   }

//   if (labeledDescriptors.length > 0) {
//     faceMatcher = new faceapi.FaceMatcher(labeledDescriptors, 0.6);
//     console.log("ƒê√£ t·∫£i xong khu√¥n m·∫∑t m·∫´u");
//   } else {
//     console.log("Kh√¥ng c√≥ d·ªØ li·ªáu khu√¥n m·∫∑t n√†o ƒë∆∞·ª£c t·∫£i!");
//   }
// };

// // üìå API Nh·∫≠n di·ªán khu√¥n m·∫∑t t·ª´ ·∫£nh upload
// app.post("/detect-face", upload.single("image"), async (req, res) => {
//   try {
//     if (!req.file) {
//       return res.status(400).json({ error: "Kh√¥ng c√≥ ·∫£nh ƒë∆∞·ª£c t·∫£i l√™n!" });
//     }

//     const imgPath = req.file.path;
//     const img = await canvas.loadImage(imgPath);
//     const detections = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();

//     if (!detections) {
//       return res.json({ name: "Unknown" });
//     }

//     if (!faceMatcher) {
//       return res.json({ name: "No face data available" });
//     }

//     const bestMatch = faceMatcher.findBestMatch(detections.descriptor);
//     res.json({ name: bestMatch.toString() });
//   } catch (error) {
//     console.error("L·ªói khi nh·∫≠n di·ªán khu√¥n m·∫∑t:", error);
//     res.status(500).json({ error: "L·ªói server!" });
//   }
// });

// // üìå Kh·ªüi ƒë·ªông server
// loadModels().then(() => {
//   app.listen(5001, () => console.log("Server is running on port 5001"));
// });



// const express = require('express');
// const multer = require('multer');
// const fs = require('fs');
// const path = require('path');
// const cors = require('cors'); // Th√™m d√≤ng n√†y
// const tf = require('@tensorflow/tfjs'); // S·ª≠ d·ª•ng @tensorflow/tfjs thay v√¨ tfjs-node
// const faceapi = require('face-api.js');
// const canvas = require('canvas');
// const { Canvas, Image, ImageData, createCanvas } = canvas;

// // Monkey patch cho face-api.js v·ªõi c√°c ƒë·ªëi t∆∞·ª£ng t·ª´ canvas
// faceapi.env.monkeyPatch({ Canvas, Image, ImageData });

// const app = express();
// app.use(cors()); // Cho ph√©p CORS cho t·∫•t c·∫£ c√°c ngu·ªìn

// const upload = multer();
// const uploadDir = path.join(__dirname, 'uploads');

// let knownFaces = [];
// let knownNames = [];

// // H√†m t·∫£i m√¥ h√¨nh t·ª´ th∆∞ m·ª•c models (ch·∫°y tr√™n Node.js)
// async function loadModels() {
//   await faceapi.nets.ssdMobilenetv1.loadFromDisk(path.join(__dirname, 'models'));
//   await faceapi.nets.faceRecognitionNet.loadFromDisk(path.join(__dirname, 'models'));
//   await faceapi.nets.faceLandmark68Net.loadFromDisk(path.join(__dirname, 'models'));
//   console.log('Models loaded');
// }

// // H√†m x·ª≠ l√Ω ·∫£nh t·ª´ th∆∞ m·ª•c uploads, tr√≠ch xu·∫•t c√°c khu√¥n m·∫∑t kh√°c nhau
// async function extractDifferentFaces() {
//   const files = fs.readdirSync(uploadDir).filter(file => file.endsWith('.jpg'));
//   let descriptors = [];

//   for (const file of files) {
//     const imgPath = path.join(uploadDir, file);
//     const img = await canvas.loadImage(imgPath);
//     // T·∫°o canvas v√† v·∫Ω ·∫£nh l√™n canvas
//     const imgCanvas = createCanvas(img.width, img.height);
//     const ctx = imgCanvas.getContext('2d');
//     ctx.drawImage(img, 0, 0, img.width, img.height);

//     const detections = await faceapi.detectAllFaces(imgCanvas)
//       .withFaceLandmarks()
//       .withFaceDescriptors();

//     detections.forEach(det => {
//       let isNewFace = true;
//       for (const knownFace of descriptors) {
//         if (faceapi.euclideanDistance(knownFace, det.descriptor) < 0.6) {
//           isNewFace = false;
//           break;
//         }
//       }
//       if (isNewFace) {
//         descriptors.push(det.descriptor);
//         knownFaces.push(det.descriptor);
//         // knownNames.push(file.replace('.jpg', ''));
//         const parts = file.split('_'); 
//         const label = parts[parts.length - 1].replace('.jpg', '');
//         knownNames.push(label);
//       }
//     });
//   }
//   console.log('Extracted different faces:', knownNames);
// }

// // Kh·ªüi t·∫°o server v√† ƒë·ªãnh nghƒ©a route /recognize
// async function startServer() {
//   app.post('/recognize', upload.single('image'), async (req, res) => {
//     if (!req.file) return res.status(400).send('No image uploaded');

//     const img = await canvas.loadImage(req.file.buffer);
//     // T·∫°o canvas v√† v·∫Ω ·∫£nh ƒë√£ upload l√™n canvas
//     const imgCanvas = createCanvas(img.width, img.height);
//     const ctx = imgCanvas.getContext('2d');
//     ctx.drawImage(img, 0, 0, img.width, img.height);

//     const detections = await faceapi.detectAllFaces(imgCanvas)
//       .withFaceLandmarks()
//       .withFaceDescriptors();

//     if (detections.length === 0) return res.status(404).send('No face detected');

//     let bestMatch = { name: 'unknown', distance: 1.0 };
//     detections.forEach(det => {
//       knownFaces.forEach((knownFace, i) => {
//         const distance = faceapi.euclideanDistance(knownFace, det.descriptor);
//         if (distance < bestMatch.distance) {
//           bestMatch = { name: knownNames[i], distance };
//         }
//       });
//     });
//     res.json({ match: bestMatch.name });
//   });

//   app.listen(5001, () => console.log('Server running on port 5001'));
// }

// (async () => {
//   await loadModels();
//   await extractDifferentFaces();
//   startServer();
// })();


// const express = require('express');
// const multer = require('multer');
// const fs = require('fs');
// const path = require('path');
// const cors = require('cors');
// const tf = require('@tensorflow/tfjs');
// const faceapi = require('face-api.js');
// const canvas = require('canvas');
// const sharp = require('sharp');
// const { Canvas, Image, ImageData, createCanvas } = canvas;
// const http = require('http');
// const socketIO = require('socket.io');

// // Monkey patch cho face-api.js v·ªõi c√°c ƒë·ªëi t∆∞·ª£ng t·ª´ canvas
// faceapi.env.monkeyPatch({ Canvas, Image, ImageData });

// const app = express();
// app.use(cors());

// const uploadDir = path.join(__dirname, 'uploads');

// let knownFaces = [];
// let knownNames = [];

// // H√†m t·∫£i m√¥ h√¨nh t·ª´ th∆∞ m·ª•c models (ch·∫°y tr√™n Node.js)
// async function loadModels() {
//   await faceapi.nets.ssdMobilenetv1.loadFromDisk(path.join(__dirname, 'models'));
//   await faceapi.nets.faceRecognitionNet.loadFromDisk(path.join(__dirname, 'models'));
//   await faceapi.nets.faceLandmark68Net.loadFromDisk(path.join(__dirname, 'models'));
//   console.log('‚úÖ Models loaded');
// }

// // H√†m chuy·ªÉn ƒë·ªïi ·∫£nh sang PNG n·∫øu l·ªói
// async function convertToPng(imgPath) {
//   const outputPath = imgPath.replace(/\.(jpg|jpeg|webp|bmp|gif)$/i, '.png');
//   try {
//     await sharp(imgPath).toFormat('png').toFile(outputPath);
//     console.log(`üîÑ ƒê√£ chuy·ªÉn ƒë·ªïi sang PNG: ${outputPath}`);
//     return outputPath;
//   } catch (error) {
//     console.error(`‚ùå L·ªói chuy·ªÉn ƒë·ªïi ·∫£nh: ${imgPath}`, error);
//     return null;
//   }
// }

// // H√†m x·ª≠ l√Ω ·∫£nh t·ª´ th∆∞ m·ª•c uploads, tr√≠ch xu·∫•t c√°c khu√¥n m·∫∑t kh√°c nhau
// async function extractDifferentFaces() {
//   const files = fs.readdirSync(uploadDir).filter(file => file.match(/\.(jpg|jpeg|png)$/i));
//   let descriptors = [];

//   for (const file of files) {
//     const imgPath = path.join(uploadDir, file);
//     console.log(`üñºÔ∏è ƒêang x·ª≠ l√Ω ·∫£nh: ${file}`);

//     let img;
//     try {
//       img = await canvas.loadImage(imgPath);
//     } catch (error) {
//       console.error(`‚ùå L·ªói khi t·∫£i ·∫£nh: ${imgPath}`, error);
//       console.log(`üîÑ Th·ª≠ chuy·ªÉn ƒë·ªïi ·∫£nh sang PNG...`);

//       const convertedPath = await convertToPng(imgPath);
//       if (!convertedPath) {
//         console.error(`‚õî Kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi ·∫£nh: ${imgPath}`);
//         continue;
//       }

//       try {
//         img = await canvas.loadImage(convertedPath);
//       } catch (error) {
//         console.error(`‚ùå L·ªói khi t·∫£i ·∫£nh sau khi chuy·ªÉn ƒë·ªïi: ${convertedPath}`, error);
//         continue;
//       }
//     }

//     console.log(`‚úÖ ·∫¢nh h·ª£p l·ªá: ${file}`);
//     const imgCanvas = createCanvas(img.width, img.height);
//     const ctx = imgCanvas.getContext('2d');
//     ctx.drawImage(img, 0, 0, img.width, img.height);

//     const detections = await faceapi.detectAllFaces(imgCanvas)
//       .withFaceLandmarks()
//       .withFaceDescriptors();

//     detections.forEach(det => {
//       let isNewFace = true;
//       for (const knownFace of descriptors) {
//         if (faceapi.euclideanDistance(knownFace, det.descriptor) < 0.6) {
//           isNewFace = false;
//           break;
//         }
//       }
//       if (isNewFace) {
//         descriptors.push(det.descriptor);
//         knownFaces.push(det.descriptor);

//         const parts = file.split('_');
//         const label = parts[parts.length - 1].replace(/\.(jpg|jpeg|png)$/, '');
//         knownNames.push(label);
//       }
//     });

//     console.log(`üé≠ S·ªë khu√¥n m·∫∑t ph√°t hi·ªán trong ${file}: ${detections.length}`);
//   }
//   console.log('‚úÖ K·∫øt qu·∫£ nh·∫≠n di·ªán:', knownNames);
// }

// const server = http.createServer(app);
// const io = socketIO(server, { cors: { origin: '*' } });

// io.on('connection', socket => {
//   console.log('Client connected');

//   socket.on('image', async (data) => {
//     try {
//       const base64Data = data.replace(/^data:image\/\w+;base64,/, '');
//       const imgBuffer = Buffer.from(base64Data, 'base64');
//       const img = await canvas.loadImage(imgBuffer);
//       const imgCanvas = createCanvas(img.width, img.height);
//       const ctx = imgCanvas.getContext('2d');
//       ctx.drawImage(img, 0, 0, img.width, img.height);

//       const detections = await faceapi.detectAllFaces(imgCanvas)
//         .withFaceLandmarks()
//         .withFaceDescriptors();

//       if (detections.length === 0) {
//         socket.emit('result', { match: 'No face detected' });
//         return;
//       }

//       let bestMatch = { name: 'unknown', distance: 1.0 };
//       detections.forEach(det => {
//         knownFaces.forEach((knownFace, i) => {
//           const distance = faceapi.euclideanDistance(knownFace, det.descriptor);
//           if (distance < bestMatch.distance) {
//             bestMatch = { name: knownNames[i], distance };
//           }
//         });
//       });

//       socket.emit('result', { match: bestMatch.name });
//     } catch (error) {
//       console.error('Error processing image:', error);
//       socket.emit('result', { match: 'Error processing image' });
//     }
//   });

//   socket.on('disconnect', () => {
//     console.log('Client disconnected');
//   });
// });

// (async () => {
//   await loadModels();
//   await extractDifferentFaces();
//   server.listen(5001, () => console.log('üöÄ Server running on port 5001'));
// })();

const express = require('express');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const cors = require('cors');
const tf = require('@tensorflow/tfjs'); // S·ª≠ d·ª•ng tfjs thu·∫ßn
const faceapi = require('face-api.js');
const canvas = require('canvas');
const sharp = require('sharp');
const { Canvas, Image, ImageData, createCanvas } = canvas;
const http = require('http');
const socketIO = require('socket.io');

faceapi.env.monkeyPatch({ Canvas, Image, ImageData });

const app = express();
app.use(cors());

const uploadDir = path.join(__dirname, 'uploads');

let knownFaces = [];
let knownNames = [];
let modelsLoaded = false;

async function loadModels() {
  const modelPath = path.join(__dirname, 'models');
  if (!modelsLoaded) {
    await faceapi.nets.ssdMobilenetv1.loadFromDisk(modelPath);
    await faceapi.nets.faceRecognitionNet.loadFromDisk(modelPath);
    await faceapi.nets.faceLandmark68Net.loadFromDisk(modelPath);
    modelsLoaded = true;
    console.log('‚úÖ Models loaded (using @tensorflow/tfjs)');
  }
}

// H√†m x·ª≠ l√Ω ·∫£nh t·ª´ th∆∞ m·ª•c upload ch·ªâ ƒë∆∞·ª£c ch·∫°y m·ªôt l·∫ßn khi kh·ªüi ƒë·ªông server
async function extractDifferentFaces() {
  const files = fs.readdirSync(uploadDir).filter(file => file.match(/\.(jpg|jpeg|png)$/i));

  for (const file of files) {
    const imgPath = path.join(uploadDir, file);
    console.log(`üñºÔ∏è ƒêang x·ª≠ l√Ω ·∫£nh: ${file}`);

    let img;
    try {
      img = await canvas.loadImage(imgPath);
    } catch (error) {
      console.error(`‚ùå L·ªói khi t·∫£i ·∫£nh: ${imgPath}`, error);
      continue;
    }

    const imgCanvas = createCanvas(img.width, img.height);
    const ctx = imgCanvas.getContext('2d');
    ctx.drawImage(img, 0, 0, img.width, img.height);

    const detections = await faceapi.detectAllFaces(imgCanvas)
      .withFaceLandmarks()
      .withFaceDescriptors();

    detections.forEach(det => {
      const label = file.replace(/^.*_([^_]+)\.(jpg|jpeg|png)$/i, '$1');
      let isNewFace = true;

      for (let i = 0; i < knownFaces.length; i++) {
        if (faceapi.euclideanDistance(knownFaces[i], det.descriptor) < 0.3) {
          isNewFace = false;
          break;
        }
      }

      if (isNewFace) {
        knownFaces.push(det.descriptor);
        if (!knownNames.includes(label)) {
          knownNames.push(label);
        }
        console.log(`üÜï Ph√°t hi·ªán khu√¥n m·∫∑t m·ªõi: ${label}`);
      }
    });

    console.log(`üé≠ S·ªë khu√¥n m·∫∑t ph√°t hi·ªán trong ${file}: ${detections.length}`);
  }

  console.log('‚úÖ K·∫øt qu·∫£ nh·∫≠n di·ªán:', knownNames);
}

// Ch·ªâ t·∫£i model v√† khu√¥n m·∫∑t m·ªôt l·∫ßn khi kh·ªüi ƒë·ªông server
(async () => {
  await loadModels();
  await extractDifferentFaces();
  const server = http.createServer(app);
  const io = socketIO(server, { cors: { origin: '*' } });

  io.on('connection', socket => {
    console.log('Client connected');

    // Khi nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu ·∫£nh qua socket, ta mong ƒë·ª£i d·ªØ li·ªáu ·ªü d·∫°ng object c√≥ 2 tr∆∞·ªùng: image (base64) v√† label (t√™n, vd: "giang")
    // socket.on('image', async (data) => {
    //   try {
    //     // Kh√¥ng c·∫ßn g·ªçi l·∫°i loadModels() v√¨ ƒë√£ ƒë∆∞·ª£c t·∫£i tr∆∞·ªõc ƒë√≥
    //     let imageData, providedLabel;
    //     if (typeof data === 'string') {
    //       imageData = data;
    //       providedLabel = null;
    //     } else {
    //       imageData = data.image;
    //       providedLabel = data.label;
    //     }

    //     const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
    //     const imgBuffer = Buffer.from(base64Data, 'base64');
    //     const img = await canvas.loadImage(imgBuffer);
    //     const imgCanvas = createCanvas(img.width, img.height);
    //     const ctx = imgCanvas.getContext('2d');
    //     ctx.drawImage(img, 0, 0, img.width, img.height);

    //     const detections = await faceapi.detectAllFaces(imgCanvas)
    //       .withFaceLandmarks()
    //       .withFaceDescriptors();

    //     if (detections.length === 0) {
    //       socket.emit('result', { match: 'No face detected' });
    //       return;
    //     }

    //     // X·ª≠ l√Ω khu√¥n m·∫∑t ƒë·∫ßu ti√™n
    //     const detection = detections[0];
    //     let bestMatch = { name: 'unknown', distance: 1.0 };
    //     knownFaces.forEach((knownFace, i) => {
    //       const distance = faceapi.euclideanDistance(knownFace, detection.descriptor);
    //       if (distance < bestMatch.distance) {
    //         bestMatch = { name: knownNames[i], distance };
    //       }
    //     });

    //     if (bestMatch.distance < 0.6) {
    //       console.log(`‚úÖ Nh·∫≠n di·ªán th√†nh c√¥ng: ${bestMatch.name}`);
    //       socket.emit('result', { match: bestMatch.name });
    //     } else {
    //       // N·∫øu kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c, th√™m khu√¥n m·∫∑t m·ªõi v√†o model n·∫øu c√≥ label ƒë∆∞·ª£c cung c·∫•p
    //       if (providedLabel) {
    //         knownFaces.push(detection.descriptor);
    //         if (!knownNames.includes(providedLabel)) {
    //           knownNames.push(providedLabel);
    //         }
    //         console.log(`üÜï Th√™m khu√¥n m·∫∑t m·ªõi: ${providedLabel}`);
    //         socket.emit('result', { match: providedLabel });
    //       } else {
    //         console.log('‚ùì Khu√¥n m·∫∑t m·ªõi kh√¥ng ƒë∆∞·ª£c nh·∫≠n di·ªán v√† kh√¥ng c√≥ label k√®m theo.');
    //         socket.emit('result', { match: 'unknown' });
    //       }
    //     }
    //   } catch (error) {
    //     console.error('Error processing image:', error);
    //     socket.emit('result', { match: 'Error processing image' });
    //   }
    // });

    
    socket.on('image', async (data) => {
      try {
        let imageData, providedLabel;
        if (typeof data === 'string') {
          imageData = data;
          providedLabel = null;
        } else {
          imageData = data.image;
          providedLabel = data.label;
        }
    
        const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
        const imgBuffer = Buffer.from(base64Data, 'base64');
        const img = await canvas.loadImage(imgBuffer);
        const imgCanvas = createCanvas(img.width, img.height);
        const ctx = imgCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0, img.width, img.height);
    
        const detections = await faceapi.detectAllFaces(imgCanvas)
          .withFaceLandmarks()
          .withFaceDescriptors();
    
        if (detections.length === 0) {
          socket.emit('result', { match: 'No face detected' });
          socket.emit('deleteImage'); // Y√™u c·∫ßu client x√≥a ·∫£nh v√† g·ª≠i ·∫£nh m·ªõi
          return;
        }
    
        const detection = detections[0];
        let bestMatch = { name: 'unknown', distance: 1.0 };
        knownFaces.forEach((knownFace, i) => {
          const distance = faceapi.euclideanDistance(knownFace, detection.descriptor);
          if (distance < bestMatch.distance) {
            bestMatch = { name: knownNames[i], distance };
          }
        });
    
        if (bestMatch.distance < 0.6) {
          console.log(`‚úÖ Nh·∫≠n di·ªán th√†nh c√¥ng: ${bestMatch.name}`);
          socket.emit('result', { match: bestMatch.name });
        } else {
          if (providedLabel) {
            knownFaces.push(detection.descriptor);
            if (!knownNames.includes(providedLabel)) {
              knownNames.push(providedLabel);
            }
            console.log(`üÜï Th√™m khu√¥n m·∫∑t m·ªõi: ${providedLabel}`);
            socket.emit('result', { match: providedLabel });
          } else {
            console.log('‚ùì Khu√¥n m·∫∑t m·ªõi kh√¥ng ƒë∆∞·ª£c nh·∫≠n di·ªán v√† kh√¥ng c√≥ label k√®m theo.');
            socket.emit('result', { match: 'unknown' });
          }
        }
    
        // Y√™u c·∫ßu client x√≥a ·∫£nh ƒë·ªÉ ti·∫øp t·ª•c nh·∫≠n di·ªán ·∫£nh m·ªõi
        socket.emit('deleteImage');
    
      } catch (error) {
        console.error('Error processing image:', error);
        socket.emit('result', { match: 'Error processing image' });
        socket.emit('deleteImage'); // X√≥a ·∫£nh d√π c√≥ l·ªói x·∫£y ra
      }
    });
    

    socket.on('disconnect', () => {
      console.log('Client disconnected');
    });
  });

  server.listen(5001, () => console.log('üöÄ Server running on port 5001'));
})();

